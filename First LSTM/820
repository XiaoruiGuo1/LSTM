import sys
import os
import math
import numpy as np
import tensorflow as tf
from tensorflow import keras
from matplotlib import pyplot as plt


# Create the dataset of subsystems
u = np.zeros(1800)
x_1 = np.zeros(1801)
x_2 = np.zeros(1801)
x_3 = np.zeros(1801)
x_4 = np.zeros(1801)
x_5 = np.zeros(1801)
x_6 = np.zeros(1801)
x_7 = np.zeros(1801)
x_8 = np.zeros(1801)
x_9 = np.zeros(1801)
x_10 = np.zeros(1801)
x_11 = np.zeros(1801)
x_12 = np.zeros(1801)
x_13 = np.zeros(1801)
x_14 = np.zeros(1801)
x_15 = np.zeros(1801)
x_16 = np.zeros(1801)
x_17 = np.zeros(1801)
x_18 = np.zeros(1801)
x_19 = np.zeros(1801)
x_20 = np.zeros(1801)

i = 0
for i in range(1800):
       u[i] = np.sin(i*np.pi/20) 
       x_1[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_2[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_3[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_4[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_5[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_6[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_7[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_8[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_9[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_10[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_11[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_12[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_13[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_14[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_15[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_16[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_17[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_18[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_19[i + 1] = 0.9*x_1[i] + 2*u[i]
       x_20[i + 1] = 0.9*x_1[i] + 2*u[i]
print(f"Shape of x_15:{x_15.shape}")

# Visualize the dataset
h = np.arange(0,1801)
def u_plot (x_axis,y_axis,x_label,y_label):
    plt.figure(figsize = (18, 6))
    plt.plot(x_axis, y_axis, color ='black')
    plt.xlabel(x_label, {'fontsize': 12}) 
    plt.ylabel(y_label, {'fontsize': 12})
u_plot (h,x_1,'h','x_1')
plt.show()

arrays_list = [x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_10,
               x_11,x_12,x_13,x_14,x_15,x_16,x_17,x_18,x_19,x_20]

x_1 = x_1.reshape(1801,1)
x_2 = x_2.reshape(1801,1)

combined_x = np.concatenate((x_1,x_2),axis=1)

for _ in arrays_list:
    _=_.reshape(1801,1)
    combined_x = np.concatenate((combined_x, _),axis=1)
print(f"Shape of combined_x: {combined_x.shape}")



'''
# Create the time series sequences
def time_series_sequence(input_dataset, output_dataset, input_length, output_length): 
    U, y = list(), list()
    for i in range(len(output_dataset)):
        end_iu = i + input_length
        end_oy = end_iu + output_length
        if end_oy > len(output_dataset):
            break
        seq_U, seq_y = input_dataset[i:end_iu].tolist(), output_dataset[end_iu:end_oy].tolist()
        U.append(seq_U)
        y.append(seq_y)
    return np.array(U), np.array(y)


# Split the dataset into train and test
y = x.reshape(1801,1)
u = u.reshape(1800,1)
train_ind = 1000
y_train = y[1:train_ind+1]
y_test = y[train_ind+1:]
u_train = u[:train_ind]
u_test = u[train_ind:]
print(f"Shape of y_train:{y_train.shape}")
print(f"shape of y_test:{y_test.shape}")
print(f"Shape of u_train:{u_train.shape}")
print(f"shape of u_test:{u_test.shape}")


# Create the 3D train, test dataset to feed into LSTM layer.
input_length = 20 
output_length = 5
U_train, Y_train = time_series_sequence(u_train, y_train, input_length, output_length)
U_test, Y_test = time_series_sequence(u_test, y_test, input_length, output_length)
print(f"Shape of U_train:{U_train.shape}")
print(f"shape of U_test:{U_test.shape}")
print(f"Shape of Y_train:{Y_train.shape}")
print(f"shape of Y_test:{Y_test.shape}")


# Build the LSTM encoder-decoder model
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, RepeatVector, TimeDistributed
from keras.callbacks import ModelCheckpoint
def encoder_decoder_model():
    model = Sequential()
    model.add(LSTM(100, activation='sigmoid',input_shape=(20,1)))
    model.add(RepeatVector(5)) #From 2D to 3D.
    model.add(LSTM(100,activation='sigmoid',return_sequences=True))
    model.add(TimeDistributed(Dense(units=1,activation = "linear")))
    return model
model = encoder_decoder_model()
model.summary()
model.compile(optimizer='adam', loss='mean_squared_error')


# Train and test
Train = model.fit(U_train, Y_train, epochs=50)
Y_predict = model.predict(U_test)
Y_pred = np.squeeze(Y_predict, axis=2)
Y_pred = Y_pred.flatten()
Y_test = np.squeeze(Y_test,axis=2)
Y_test = Y_test.flatten()


# Visualize the results
fig, ax = plt.subplots(1, 1, figsize=(15, 8))
ax.plot(Y_test, lw=3, c='y', label='test data')
ax.plot(Y_pred, lw=4, c='r',linestyle = ':', label='predictions')
ax.legend(loc="lower left")
plt.show();
'''